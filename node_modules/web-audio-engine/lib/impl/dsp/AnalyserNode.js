"use strict";

var fft = require("fourier-transform");
var blackman = require("scijs-window-functions/blackman");
var AudioBus = require("../core/AudioBus");

var _require = require("../../utils"),
    toDecibel = _require.toDecibel,
    normalize = _require.normalize;

var MAX_FFT_SIZE = 32768;

var AnalyserNodeDSP = {
  dspInit: function dspInit(sampleRate) {
    this._timeDomainBuffer = [];
    this._analyserBus = new AudioBus(1, MAX_FFT_SIZE, sampleRate);
    this._analyserBusOffset = 0;
    this._audioData = this._analyserBus.audioData.channelData[0];
  },
  dspUpdateSizes: function dspUpdateSizes(fftSize) {
    var previousSmooth = new Float32Array(fftSize / 2);
    var blackmanTable = new Float32Array(fftSize);

    for (var i = 0; i < fftSize; i++) {
      blackmanTable[i] = blackman(i, fftSize);
    }

    this._previousSmooth = previousSmooth;
    this._blackmanTable = blackmanTable;
  },
  dspGetFloatFrequencyData: function dspGetFloatFrequencyData(array) {
    var fftSize = this._fftSize;
    var blackmanTable = this._blackmanTable;
    var previousSmooth = this._previousSmooth;
    var waveform = new Float32Array(fftSize);
    var length = Math.min(array.length, fftSize / 2);
    var s = this._smoothingTimeConstant;

    // 1. down-mix
    this.dspGetFloatTimeDomainData(waveform);

    // 2. Apply Blackman window
    for (var i = 0; i < fftSize; i++) {
      waveform[i] = waveform[i] * blackmanTable[i] || 0;
    }

    // 3. FFT
    var spectrum = fft(waveform);

    // re-size to frequencyBinCount, then do more processing
    for (var _i = 0; _i < length; _i++) {
      var v0 = spectrum[_i];
      // 4. Smooth over data
      previousSmooth[_i] = s * previousSmooth[_i] + (1 - s) * v0;
      // 5. Convert to dB
      var v1 = toDecibel(previousSmooth[_i]);
      // store in array
      array[_i] = Number.isFinite(v1) ? v1 : 0;
    }
  },
  dspGetByteFrequencyData: function dspGetByteFrequencyData(array) {
    var length = Math.min(array.length, this._fftSize / 2);
    var dBMin = this._minDecibels;
    var dBMax = this._maxDecibels;
    var spectrum = new Float32Array(length);

    this.dspGetFloatFrequencyData(spectrum);

    for (var i = 0; i < length; i++) {
      array[i] = Math.round(normalize(spectrum[i], dBMin, dBMax) * 255);
    }
  },
  dspGetByteTimeDomainData: function dspGetByteTimeDomainData(array) {
    var length = Math.min(array.length, this._fftSize);
    var waveform = new Float32Array(length);

    this.dspGetFloatTimeDomainData(waveform);

    for (var i = 0; i < length; i++) {
      array[i] = Math.round(normalize(waveform[i], -1, 1) * 255);
    }
  },
  dspGetFloatTimeDomainData: function dspGetFloatTimeDomainData(array) {
    var audioData = this._audioData;
    var fftSize = this._fftSize;
    var i0 = (this._analyserBusOffset - fftSize + MAX_FFT_SIZE) % MAX_FFT_SIZE;
    var i1 = Math.min(i0 + fftSize, MAX_FFT_SIZE);
    var copied = i1 - i0;

    array.set(audioData.subarray(i0, i1));

    if (copied !== fftSize) {
      var remain = fftSize - copied;
      var subarray2 = audioData.subarray(0, remain);

      array.set(subarray2, copied);
    }
  },
  dspProcess: function dspProcess() {
    var inputBus = this.inputs[0].bus;
    var outputBus = this.outputs[0].bus;
    var analyserBus = this._analyserBus;
    var blockSize = inputBus.audioData.length;

    // just pass data through
    outputBus.copyFrom(inputBus);

    // merge and store data in our buffer
    analyserBus.copyFromWithOffset(inputBus, this._analyserBusOffset);

    this._analyserBusOffset += blockSize;
    if (MAX_FFT_SIZE <= this._analyserBusOffset) {
      this._analyserBusOffset = 0;
    }
  }
};

module.exports = AnalyserNodeDSP;