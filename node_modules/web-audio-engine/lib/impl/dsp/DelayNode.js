"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DelayNodeDSP = {
  dspInit: function dspInit(maxDelayTime) {
    this._kernels = [];
    this._delayBufferLength = this.dspComputeDelayBufferLength(maxDelayTime);
    this._delayIndices = new Float32Array(this.blockSize);
  },
  dspComputeDelayBufferLength: function dspComputeDelayBufferLength(delayTime) {
    return Math.ceil(delayTime * this.sampleRate / this.blockSize) * this.blockSize + this.blockSize;
  },
  dspUpdateKernel: function dspUpdateKernel(numberOfChannels) {
    if (numberOfChannels < this._kernels.length) {
      this._kernels.splice(numberOfChannels);
    } else if (this._kernels.length < numberOfChannels) {
      while (numberOfChannels !== this._kernels.length) {
        this._kernels.push(new DelayKernel(this, this._kernels.length));
      }
    }

    switch (numberOfChannels) {
      case 1:
        this.dspProcess = this.dspProcess1;
        break;
      case 2:
        this.dspProcess = this.dspProcess2;
        break;
      default:
        this.dspProcess = this.dspProcessN;
        break;
    }
  },
  dspProcess1: function dspProcess1() {
    var blockSize = this.blockSize;
    var inputs = this.inputs[0].bus.getChannelData();
    var outputs = this.outputs[0].bus.getMutableData();
    var delayIndices = this._delayIndices;
    var kernel = this._kernels[0];

    if (this._delayTime.hasSampleAccurateValues()) {
      kernel.computeAccurateDelayIndices(delayIndices, this._delayTime.getSampleAccurateValues());
      kernel.processWithAccurateDelayIndices(inputs[0], outputs[0], delayIndices, blockSize);
    } else {
      kernel.computeStaticDelayIndices(delayIndices, this._delayTime.getValue());
      kernel.processWithStaticDelayIndices(inputs[0], outputs[0], delayIndices, blockSize);
    }
  },
  dspProcess2: function dspProcess2() {
    var blockSize = this.blockSize;
    var inputs = this.inputs[0].bus.getChannelData();
    var outputs = this.outputs[0].bus.getMutableData();
    var delayIndices = this._delayIndices;
    var kernels = this._kernels;

    if (this._delayTime.hasSampleAccurateValues()) {
      kernels[0].computeAccurateDelayIndices(delayIndices, this._delayTime.getSampleAccurateValues());
      kernels[0].processWithAccurateDelayIndices(inputs[0], outputs[0], delayIndices, blockSize);
      kernels[1].processWithAccurateDelayIndices(inputs[1], outputs[1], delayIndices, blockSize);
    } else {
      kernels[0].computeStaticDelayIndices(delayIndices, this._delayTime.getValue());
      kernels[0].processWithStaticDelayIndices(inputs[0], outputs[0], delayIndices, blockSize);
      kernels[1].processWithStaticDelayIndices(inputs[1], outputs[1], delayIndices, blockSize);
    }
  },
  dspProcessN: function dspProcessN() {
    var blockSize = this.blockSize;
    var inputs = this.inputs[0].bus.getChannelData();
    var outputs = this.outputs[0].bus.getMutableData();
    var delayIndices = this._delayIndices;
    var kernels = this._kernels;

    if (this._delayTime.hasSampleAccurateValues()) {
      kernels[0].computeAccurateDelayIndices(delayIndices, this._delayTime.getSampleAccurateValues());

      for (var i = 0, imax = kernels.length; i < imax; i++) {
        kernels[i].processWithAccurateDelayIndices(inputs[i], outputs[i], delayIndices, blockSize);
      }
    } else {
      kernels[0].computeStaticDelayIndices(delayIndices, this._delayTime.getValue());

      for (var _i = 0, _imax = kernels.length; _i < _imax; _i++) {
        kernels[_i].processWithStaticDelayIndices(inputs[_i], outputs[_i], delayIndices, blockSize);
      }
    }
  }
};

var DelayKernel = function () {
  function DelayKernel(delayNode) {
    _classCallCheck(this, DelayKernel);

    this._sampleRate = delayNode.sampleRate;
    this._maxDelayTime = delayNode._maxDelayTime;
    this._delayBufferLength = delayNode._delayBufferLength;
    this._delayBuffer = new Float32Array(this._delayBufferLength);
    this._virtualDelayIndex = 0;
  }

  _createClass(DelayKernel, [{
    key: "computeStaticDelayIndices",
    value: function computeStaticDelayIndices(delayIndices, delayTime) {
      var sampleRate = this._sampleRate;
      var maxDelayTime = this._maxDelayTime;
      var delayBufferLength = this._delayBufferLength;
      var virtualReadIndex = this._virtualDelayIndex;

      delayTime = Math.max(0, Math.min(delayTime, maxDelayTime));

      var delayIndex = virtualReadIndex - delayTime * sampleRate;

      if (delayIndex < 0) {
        delayIndex += delayBufferLength;
      }

      for (var i = 0, imax = delayIndices.length; i < imax; i++) {
        delayIndices[i] = delayIndex++;
        if (delayBufferLength <= delayIndex) {
          delayIndex -= delayBufferLength;
        }
      }

      return delayIndices;
    }
  }, {
    key: "computeAccurateDelayIndices",
    value: function computeAccurateDelayIndices(delayIndices, delayTimes) {
      var sampleRate = this._sampleRate;
      var maxDelayTime = this._maxDelayTime;
      var delayBufferLength = this._delayBufferLength;
      var virtualReadIndex = this._virtualDelayIndex;

      for (var i = 0, imax = delayIndices.length; i < imax; i++) {
        var delayTime = Math.max(0, Math.min(delayTimes[i], maxDelayTime));

        var delayIndex = virtualReadIndex + i - delayTime * sampleRate;

        if (delayIndex < 0) {
          delayIndex += delayBufferLength;
        }

        delayIndices[i] = delayIndex;
      }

      return delayIndices;
    }
  }, {
    key: "processWithStaticDelayIndices",
    value: function processWithStaticDelayIndices(input, output, delayIndices, inNumSamples) {
      var delayBufferLength = this._delayBufferLength;
      var delayBuffer = this._delayBuffer;

      this._delayBuffer.set(input, this._virtualDelayIndex);

      var ia = delayIndices[0] % 1;

      if (ia === 0) {
        for (var i = 0; i < inNumSamples; i++) {
          output[i] = delayBuffer[delayIndices[i]];
        }
      } else {
        for (var _i2 = 0; _i2 < inNumSamples; _i2++) {
          var i0 = delayIndices[_i2] | 0;
          var i1 = (i0 + 1) % delayBufferLength;

          output[_i2] = delayBuffer[i0] + ia * (delayBuffer[i1] - delayBuffer[i0]);
        }
      }

      this._virtualDelayIndex += inNumSamples;

      if (this._virtualDelayIndex === delayBufferLength) {
        this._virtualDelayIndex = 0;
      }
    }
  }, {
    key: "processWithAccurateDelayIndices",
    value: function processWithAccurateDelayIndices(input, output, delayIndices, inNumSamples) {
      var delayBufferLength = this._delayBufferLength;
      var delayBuffer = this._delayBuffer;

      delayBuffer.set(input, this._virtualDelayIndex);

      for (var i = 0; i < inNumSamples; i++) {
        var ix = delayIndices[i];
        var i0 = ix | 0;
        var ia = ix % 1;

        if (ia === 0) {
          output[i] = delayBuffer[i0];
        } else {
          var i1 = (i0 + 1) % delayBufferLength;

          output[i] = delayBuffer[i0] + ia * (delayBuffer[i1] - delayBuffer[i0]);
        }
      }

      this._virtualDelayIndex += inNumSamples;

      if (this._virtualDelayIndex === delayBufferLength) {
        this._virtualDelayIndex = 0;
      }
    }
  }]);

  return DelayKernel;
}();

module.exports = DelayNodeDSP;