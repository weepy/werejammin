"use strict";

var AudioBufferSourceNodeDSP = {
  dspInit: function dspInit() {
    this._phase = 0;
  },
  dspStart: function dspStart() {
    if (this._audioData) {
      var bufferSampleRate = this._audioData.sampleRate;
      var bufferDuration = this._audioData.length / bufferSampleRate;

      this._phase = Math.max(0, Math.min(this._offset, bufferDuration)) * bufferSampleRate;
    }
  },
  dspProcess: function dspProcess() {
    if (this._audioData === null) {
      return this.dspEmitEnded();
    }

    var blockSize = this.blockSize;
    var quantumStartFrame = this.context.currentSampleFrame;
    var quantumEndFrame = quantumStartFrame + blockSize;
    var sampleOffset = Math.max(0, this._startFrame - quantumStartFrame);
    var fillToSample = Math.min(quantumEndFrame, this._stopFrame) - quantumStartFrame;
    var outputs = this.outputs[0].bus.getMutableData();

    var writeIndex = 0;

    writeIndex = this.dspBufferRendering(outputs, sampleOffset, fillToSample, this.sampleRate);

    // timeline
    // |----------------|-------*--------|----------------|----------------|
    //                  ^       ^        ^
    //                  |------>|        quantumEndFrame
    //                  | wrote |
    //                  |       stopFrame
    //                  quantumStartFrame
    if (this._stopFrame <= quantumStartFrame + writeIndex) {
      // rest samples fill zero
      var numberOfChannels = outputs.length;

      while (writeIndex < blockSize) {
        for (var ch = 0; ch < numberOfChannels; ch++) {
          outputs[ch][writeIndex] = 0;
        }
        writeIndex += 1;
      }

      this.dspEmitEnded();
    }
  },
  dspBufferRendering: function dspBufferRendering(outputs, writeIndex, inNumSamples, sampleRate) {
    var playbackRateValues = this._playbackRate.getSampleAccurateValues();
    var detuneValues = this._detune.getSampleAccurateValues();
    var numberOfChannels = this._audioData.numberOfChannels;
    var bufferLength = this._audioData.length;
    var bufferSampleRate = this._audioData.sampleRate;
    var bufferChannelData = this._audioData.channelData;
    var playbackRateToPhaseIncr = bufferSampleRate / sampleRate;

    var phase = this._phase;

    while (writeIndex < inNumSamples) {
      var playbackRateValue = playbackRateValues[writeIndex];
      var detuneValue = detuneValues[writeIndex];
      var computedPlaybackRate = playbackRateValue * Math.pow(2, detuneValue / 1200);

      for (var ch = 0; ch < numberOfChannels; ch++) {
        var v0 = bufferChannelData[ch][phase | 0] || 0;
        var v1 = bufferChannelData[ch][(phase | 0) + 1] || 0;

        outputs[ch][writeIndex] = v0 + phase % 1 * (v1 - v0);
      }
      writeIndex += 1;

      phase += playbackRateToPhaseIncr * Math.max(0, computedPlaybackRate);

      if (this._loop) {
        if (0 <= this._loopStart && this._loopStart < this._loopEnd) {
          var loopEndSamples = this._loopEnd * bufferSampleRate;

          if (loopEndSamples <= phase) {
            phase = this._loopStart * bufferSampleRate;
          }
        } else {
          if (bufferLength <= phase) {
            phase = 0;
          }
        }
      } else {
        if (bufferLength <= phase) {
          this.dspEmitEnded();
          break;
        }
      }
    }

    this._phase = phase;

    return writeIndex;
  },
  dspEmitEnded: function dspEmitEnded() {
    var _this = this;

    this._done = true;
    this.context.addPostProcess(function () {
      _this.outputs[0].bus.zeros();
      _this.outputs[0].disable();
      _this.dispatchEvent({ type: "ended" });
    });
  }
};

module.exports = AudioBufferSourceNodeDSP;