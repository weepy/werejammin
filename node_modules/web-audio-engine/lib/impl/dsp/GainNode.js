"use strict";

var DSPAlgorithm = {};

var GainNodeDSP = {
  dspProcess: function dspProcess() {
    var inputBus = this.inputs[0].bus;
    var outputBus = this.outputs[0].bus;

    if (inputBus.isSilent) {
      outputBus.zeros();
      return;
    }

    var gainParam = this._gain;

    if (gainParam.hasSampleAccurateValues()) {
      var _inputs = inputBus.getChannelData();
      var _outputs = outputBus.getMutableData();
      var gainValues = gainParam.getSampleAccurateValues();
      var _numberOfChannels = _inputs.length;
      var _dsp = selectAlgorithm(_numberOfChannels, 1000);

      _dsp(_inputs, _outputs, gainValues, this.blockSize);

      return;
    }

    var gainValue = gainParam.getValue();

    if (gainValue === 0) {
      outputBus.zeros();
      return;
    }

    if (gainValue === 1) {
      outputBus.copyFrom(inputBus);
      return;
    }

    var inputs = inputBus.getChannelData();
    var outputs = outputBus.getMutableData();
    var numberOfChannels = outputs.length;
    var dsp = selectAlgorithm(numberOfChannels, 2000);

    dsp(inputs, outputs, gainValue, this.blockSize);
  }
};

function selectAlgorithm(numberOfChannels, base) {
  var algorithmIndex = numberOfChannels + base;

  if (DSPAlgorithm[algorithmIndex]) {
    return DSPAlgorithm[algorithmIndex];
  }

  return DSPAlgorithm[base];
}

DSPAlgorithm[1000] = function (inputs, outputs, gainValues, blockSize) {
  var numberOfChannels = inputs.length;

  for (var ch = 0; ch < numberOfChannels; ch++) {
    for (var i = 0; i < blockSize; i++) {
      outputs[ch][i] = inputs[ch][i] * gainValues[i];
    }
  }
};

DSPAlgorithm[1001] = function (inputs, outputs, gainValues, blockSize) {
  var input = inputs[0];
  var output = outputs[0];

  for (var i = 0; i < blockSize; i++) {
    output[i] = input[i] * gainValues[i];
  }
};

DSPAlgorithm[1002] = function (inputs, outputs, gainValues, blockSize) {
  var inputL = inputs[0];
  var inputR = inputs[1];
  var outputL = outputs[0];
  var outputR = outputs[1];

  for (var i = 0; i < blockSize; i++) {
    outputL[i] = inputL[i] * gainValues[i];
    outputR[i] = inputR[i] * gainValues[i];
  }
};

DSPAlgorithm[2000] = function (inputs, outputs, gainValue, blockSize) {
  var numberOfChannels = inputs.length;

  for (var ch = 0; ch < numberOfChannels; ch++) {
    for (var i = 0; i < blockSize; i++) {
      outputs[ch][i] = inputs[ch][i] * gainValue;
    }
  }
};

DSPAlgorithm[2001] = function (inputs, outputs, gainValue, blockSize) {
  var input = inputs[0];
  var output = outputs[0];

  for (var i = 0; i < blockSize; i++) {
    output[i] = input[i] * gainValue;
  }
};

DSPAlgorithm[2002] = function (inputs, outputs, gainValue, blockSize) {
  var inputL = inputs[0];
  var inputR = inputs[1];
  var outputL = outputs[0];
  var outputR = outputs[1];

  for (var i = 0; i < blockSize; i++) {
    outputL[i] = inputL[i] * gainValue;
    outputR[i] = inputR[i] * gainValue;
  }
};

module.exports = GainNodeDSP;