"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventTarget = require("./EventTarget");
var AudioNodeInput = require("./core/AudioNodeInput");
var AudioNodeOutput = require("./core/AudioNodeOutput");
var AudioParam = require("./AudioParam");

var _require = require("../utils"),
    defaults = _require.defaults,
    clamp = _require.clamp;

var _require2 = require("../utils"),
    toNumber = _require2.toNumber;

var _require3 = require("../constants"),
    MIN_NUMBER_OF_CHANNELS = _require3.MIN_NUMBER_OF_CHANNELS,
    MAX_NUMBER_OF_CHANNELS = _require3.MAX_NUMBER_OF_CHANNELS;

var _require4 = require("../constants/ChannelCountMode"),
    MAX = _require4.MAX,
    CLAMPED_MAX = _require4.CLAMPED_MAX,
    EXPLICIT = _require4.EXPLICIT;

var _require5 = require("../constants/ChannelInterpretation"),
    DISCRETE = _require5.DISCRETE,
    SPEAKERS = _require5.SPEAKERS;

/**
 * @prop {AudioContext}      context
 * @prop {number}            blockSize
 * @prop {number}            sampleRate
 * @prop {AudioNodeInput[]}  inputs
 * @prop {AudioNodeOutput[]} outputs
 */


var AudioNode = function (_EventTarget) {
  _inherits(AudioNode, _EventTarget);

  /**
   * @param {AudioContext} context
   * @param {object}       opts
   * @param {number}       opts.channelCount
   * @param {string}       opts.channelCountMode
   * @param {string}       opts.channelInterpretation
   * @param {number[]}     config.inputs
   * @param {number[]}     config.outputs
   * @param {number}       config.channelCount
   * @param {string}       config.channelCountMode
   */
  function AudioNode(context) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, AudioNode);

    var inputs = defaults(config.inputs, []);
    var outputs = defaults(config.outputs, []);
    var channelCount = defaults(config.channelCount, 1);
    var channelCountMode = defaults(config.channelCountMode, MAX);
    var channelInterpretation = SPEAKERS;
    var allowedMinChannelCount = defaults(config.allowedMinChannelCount, MIN_NUMBER_OF_CHANNELS);
    var allowedMaxChannelCount = defaults(config.allowedMaxChannelCount, MAX_NUMBER_OF_CHANNELS);
    var allowedChannelCountMode = defaults(config.allowedChannelCountMode, [MAX, CLAMPED_MAX, EXPLICIT]);
    var allowedChannelInterpretation = defaults(config.allowedChannelInterpretation, [DISCRETE, SPEAKERS]);

    var _this = _possibleConstructorReturn(this, (AudioNode.__proto__ || Object.getPrototypeOf(AudioNode)).call(this));

    _this.context = context;
    _this.blockSize = context.blockSize;
    _this.sampleRate = context.sampleRate;
    _this.inputs = [];
    _this.outputs = [];
    _this.channelCount = channelCount;
    _this.channelCountMode = channelCountMode;
    _this.channelInterpretation = channelInterpretation;
    _this.allowedMinChannelCount = allowedMinChannelCount;
    _this.allowedMaxChannelCount = allowedMaxChannelCount;
    _this.allowedChannelCountMode = allowedChannelCountMode;
    _this.allowedChannelInterpretation = allowedChannelInterpretation;
    _this.currentSampleFrame = -1;

    _this._params = [];
    _this._enabled = false;
    _this._suicideAtSampleFrame = Infinity;

    inputs.forEach(function (numberOfChannels) {
      _this.addInput(numberOfChannels, channelCount, channelCountMode);
    });
    outputs.forEach(function (numberOfChannels) {
      _this.addOutput(numberOfChannels);
    });

    if (typeof opts.channelCount === "number") {
      _this.setChannelCount(opts.channelCount);
    }
    if (typeof opts.channelCountMode === "string") {
      _this.setChannelCountMode(opts.channelCountMode);
    }
    if (typeof opts.channelInterpretation === "string") {
      _this.setChannelInterpretation(opts.channelInterpretation);
    }
    return _this;
  }

  /**
   * @return {number}
   */


  _createClass(AudioNode, [{
    key: "getNumberOfInputs",
    value: function getNumberOfInputs() {
      return this.inputs.length;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getNumberOfOutputs",
    value: function getNumberOfOutputs() {
      return this.outputs.length;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getChannelCount",
    value: function getChannelCount() {
      return this.channelCount;
    }

    /**
     * @param {number} value
     */

  }, {
    key: "setChannelCount",
    value: function setChannelCount(value) {
      value = toNumber(value);

      var channelCount = clamp(value, this.allowedMinChannelCount, this.allowedMaxChannelCount);

      if (channelCount !== this.channelCount) {
        this.channelCount = channelCount;
        this.inputs.forEach(function (input) {
          input.setChannelCount(value);
        });
      }
    }

    /**
     * @return {string}
     */

  }, {
    key: "getChannelCountMode",
    value: function getChannelCountMode() {
      return this.channelCountMode;
    }

    /**
     * @param {string} value
     */

  }, {
    key: "setChannelCountMode",
    value: function setChannelCountMode(value) {
      if (this.allowedChannelCountMode.indexOf(value) !== -1) {
        if (value !== this.channelCountMode) {
          this.channelCountMode = value;
          this.inputs.forEach(function (input) {
            input.setChannelCountMode(value);
          });
        }
      }
    }

    /**
     * @return {string}
     */

  }, {
    key: "getChannelInterpretation",
    value: function getChannelInterpretation() {
      return this.channelInterpretation;
    }

    /**
     * @param {string} value
     */

  }, {
    key: "setChannelInterpretation",
    value: function setChannelInterpretation(value) {
      if (this.allowedChannelInterpretation.indexOf(value) !== -1) {
        if (value !== this.channelInterpretation) {
          this.channelInterpretation = value;
          this.inputs.forEach(function (input) {
            input.setChannelInterpretation(value);
          });
        }
      }
    }

    /**
     * @param {AudioNode|AudioParam} destination
     * @param {number}               output
     * @param {number}               input
     */

  }, {
    key: "connect",
    value: function connect(destination, output, input) {
      this.outputs[output | 0].connect(destination, input | 0);
    }

    /**
     *
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      if (arguments.length === 0) {
        return this.disconnectAll();
      }
      if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === "number") {
        return this.disconnectAllFromOutput((arguments.length <= 0 ? undefined : arguments[0]) | 0);
      }
      if (arguments.length === 1) {
        return this.disconnectIfConnected(arguments.length <= 0 ? undefined : arguments[0]);
      }
      return this.disconnectFromOutputIfConnected((arguments.length <= 1 ? undefined : arguments[1]) | 0, arguments.length <= 0 ? undefined : arguments[0], (arguments.length <= 2 ? undefined : arguments[2]) | 0);
    }

    /**
     * @param {number} numberOfChannels
     * @param {number} channelCount
     * @param {string} channelCountMode
     * @return {AudioNodeInput}
     */

  }, {
    key: "addInput",
    value: function addInput(numberOfChannels, channelCount, channelCountMode) {
      var node = this;
      var index = this.inputs.length;
      var input = new AudioNodeInput({ node: node, index: index, numberOfChannels: numberOfChannels, channelCount: channelCount, channelCountMode: channelCountMode });

      this.inputs.push(input);

      return input;
    }

    /**
     * @param {number} numberOfChannels
     * @return {AudioNodeOutput}
     */

  }, {
    key: "addOutput",
    value: function addOutput(numberOfChannels) {
      var node = this;
      var index = this.outputs.length;
      var output = new AudioNodeOutput({ node: node, index: index, numberOfChannels: numberOfChannels });

      this.outputs.push(output);

      return output;
    }

    /**
     * @param {string} rate - [ "audio", "control" ]
     * @param {number} defaultValue
     * @return {AudioParam}
     */

  }, {
    key: "addParam",
    value: function addParam(rate, defaultValue) {
      var param = new AudioParam(this.context, { rate: rate, defaultValue: defaultValue });

      this._params.push(param);

      return param;
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._enabled;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getTailTime",
    value: function getTailTime() {
      return 0;
    }

    /**
     *
     */

  }, {
    key: "enableOutputsIfNecessary",
    value: function enableOutputsIfNecessary() {
      if (!this._enabled) {
        this._suicideAtSampleFrame = Infinity;
        this._enabled = true;
        this.outputs.forEach(function (output) {
          output.enable();
        });
      }
    }

    /**
     *
     */

  }, {
    key: "disableOutputsIfNecessary",
    value: function disableOutputsIfNecessary() {
      var currentTime = this.context.currentTime;
      var disableAtTime = currentTime + this.getTailTime();

      if (disableAtTime === currentTime) {
        this._disableOutputsIfNecessary();
      } else if (disableAtTime !== Infinity) {
        this._suicideAtSampleFrame = Math.round(disableAtTime * this.sampleRate);
      }
    }

    /**
     * @private
     */

  }, {
    key: "_disableOutputsIfNecessary",
    value: function _disableOutputsIfNecessary() {
      if (this._enabled) {
        this._enabled = false;
        this.outputs.forEach(function (output) {
          output.disable();
        });
      }
    }

    /**
     *
     */

  }, {
    key: "channelDidUpdate",
    value: function channelDidUpdate() {}

    /**
     *
     */

  }, {
    key: "disconnectAll",
    value: function disconnectAll() {
      this.outputs.forEach(function (output) {
        output.disconnect();
      });
    }

    /**
     * @param {number} output
     */

  }, {
    key: "disconnectAllFromOutput",
    value: function disconnectAllFromOutput(output) {
      this.outputs[output | 0].disconnect();
    }

    /**
     * @param {AudioNode|AudioParam} destination
     */

  }, {
    key: "disconnectIfConnected",
    value: function disconnectIfConnected(destination) {
      this.outputs.forEach(function (output) {
        output.disconnect(destination);
      });
    }

    /**
     * @param {number} output
     * @param {AudioNode|AudioParam} destination
     * @param {number} output
     */

  }, {
    key: "disconnectFromOutputIfConnected",
    value: function disconnectFromOutputIfConnected(output, destination, input) {
      this.outputs[output | 0].disconnect(destination, input | 0);
    }

    /**
     *
     */

  }, {
    key: "processIfNecessary",
    value: function processIfNecessary() {
      var _this2 = this;

      // prevent infinite loop when audio graph has feedback
      if (this.context.currentSampleFrame <= this.currentSampleFrame) {
        return;
      }
      this.currentSampleFrame = this.context.currentSampleFrame;

      if (this._suicideAtSampleFrame <= this.currentSampleFrame) {
        var outputs = this.outputs;

        for (var i = 0, imax = outputs.length; i < imax; i++) {
          outputs[i].zeros();
        }

        this.context.addPostProcess(function () {
          _this2._disableOutputsIfNecessary();
        });
        return;
      }

      var inputs = this.inputs;

      for (var _i = 0, _imax = inputs.length; _i < _imax; _i++) {
        inputs[_i].pull();
      }

      var params = this._params;

      for (var _i2 = 0, _imax2 = params.length; _i2 < _imax2; _i2++) {
        params[_i2].dspProcess();
      }

      this.dspProcess();
    }
  }, {
    key: "dspInit",
    value: function dspInit() {}
  }, {
    key: "dspProcess",
    value: function dspProcess() {}
  }]);

  return AudioNode;
}(EventTarget);

module.exports = AudioNode;