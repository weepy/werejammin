"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioNodeInput = require("./core/AudioNodeInput");
var AudioBus = require("./core/AudioBus");
var AudioParamDSP = require("./dsp/AudioParam");

var _require = require("../utils"),
    defaults = _require.defaults;

var _require2 = require("../utils"),
    toNumber = _require2.toNumber;

var _require3 = require("../constants/ChannelCountMode"),
    EXPLICIT = _require3.EXPLICIT;

var _require4 = require("../constants/AudioParamRate"),
    CONTROL_RATE = _require4.CONTROL_RATE;

var _require5 = require("../constants/AudioParamEvent"),
    SET_VALUE_AT_TIME = _require5.SET_VALUE_AT_TIME;

var _require6 = require("../constants/AudioParamEvent"),
    LINEAR_RAMP_TO_VALUE_AT_TIME = _require6.LINEAR_RAMP_TO_VALUE_AT_TIME;

var _require7 = require("../constants/AudioParamEvent"),
    EXPONENTIAL_RAMP_TO_VALUE_AT_TIME = _require7.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME;

var _require8 = require("../constants/AudioParamEvent"),
    SET_TARGET_AT_TIME = _require8.SET_TARGET_AT_TIME;

var _require9 = require("../constants/AudioParamEvent"),
    SET_VALUE_CURVE_AT_TIME = _require9.SET_VALUE_CURVE_AT_TIME;

/**
 * @prop {AudioContext}      context
 * @prop {number}            blockSize
 * @prop {number}            sampleRate
 * @prop {AudioNodeInput[]}  inputs
 * @prop {AudioBus}          outputBus
 */


var AudioParam = function () {
  /**
   * @param {AudioContext} context
   * @param {string}       opts.rate - [ AUDIO_RATE, CONTROL_RATE ]
   * @param {number}       opts.defaultValue
   */
  function AudioParam(context) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, AudioParam);

    var rate = defaults(opts.rate, CONTROL_RATE);
    var defaultValue = defaults(opts.defaultValue, 0);

    this.context = context;
    this.blockSize = context.blockSize;
    this.sampleRate = context.sampleRate;
    this.inputs = [new AudioNodeInput({
      node: this,
      index: 0,
      numberOfChannels: 1,
      channelCount: 1,
      channelCountMode: EXPLICIT
    })];
    this.outputBus = new AudioBus(1, this.blockSize, this.sampleRate);

    this._rate = rate;
    this._defaultValue = toNumber(defaultValue);
    this._value = this._defaultValue;
    this._userValue = this._value;
    this._timeline = [];

    this.dspInit(this._rate);
  }

  /**
   * @return {number}
   */


  _createClass(AudioParam, [{
    key: "getValue",
    value: function getValue() {
      return this._value;
    }

    /**
     * @param {number} value
     */

  }, {
    key: "setValue",
    value: function setValue(value) {
      this._value = this._userValue = toNumber(value);
    }

    /**
     * @return {number}
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return this._defaultValue;
    }

    /**
     * @param {number} value
     * @param {number} startTime
     */

  }, {
    key: "setValueAtTime",
    value: function setValueAtTime(value, startTime) {
      value = toNumber(value);
      startTime = Math.max(0, toNumber(startTime));

      var eventItem = {
        type: SET_VALUE_AT_TIME,
        time: startTime,
        args: [value, startTime],
        startFrame: Math.round(startTime * this.sampleRate),
        endFrame: Infinity,
        startValue: value,
        endValue: value
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case SET_VALUE_AT_TIME:
          case SET_TARGET_AT_TIME:
            prevEventItem.endFrame = eventItem.startFrame;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.startFrame;
            nextEventItem.startValue = eventItem.startValue;
            break;
        }
        eventItem.endFrame = nextEventItem.startFrame;
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} value
     * @param {number} endTime
     */

  }, {
    key: "linearRampToValueAtTime",
    value: function linearRampToValueAtTime(value, endTime) {
      value = toNumber(value);
      endTime = Math.max(0, toNumber(endTime));

      var eventItem = {
        type: LINEAR_RAMP_TO_VALUE_AT_TIME,
        time: endTime,
        args: [value, endTime],
        startFrame: 0,
        endFrame: Math.round(endTime * this.sampleRate),
        startValue: this._defaultValue,
        endValue: value
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case SET_VALUE_AT_TIME:
          case SET_TARGET_AT_TIME:
            eventItem.startFrame = prevEventItem.startFrame;
            eventItem.startValue = prevEventItem.startValue;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          case SET_VALUE_CURVE_AT_TIME:
            eventItem.startFrame = prevEventItem.endFrame;
            eventItem.startValue = prevEventItem.endValue;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.endFrame;
            nextEventItem.startValue = eventItem.endValue;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} value
     * @param {number} endTime
     */

  }, {
    key: "exponentialRampToValueAtTime",
    value: function exponentialRampToValueAtTime(value, endTime) {
      value = Math.max(1e-6, toNumber(value));
      endTime = Math.max(0, toNumber(endTime));

      var eventItem = {
        type: EXPONENTIAL_RAMP_TO_VALUE_AT_TIME,
        time: endTime,
        args: [value, endTime],
        startFrame: 0,
        endFrame: Math.round(endTime * this.sampleRate),
        startValue: Math.max(1e-6, this._defaultValue),
        endValue: value
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case SET_VALUE_AT_TIME:
          case SET_TARGET_AT_TIME:
            eventItem.startFrame = prevEventItem.startFrame;
            eventItem.startValue = prevEventItem.startValue;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          case SET_VALUE_CURVE_AT_TIME:
            eventItem.startFrame = prevEventItem.endFrame;
            eventItem.startValue = prevEventItem.endValue;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.endFrame;
            nextEventItem.startValue = eventItem.endValue;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} target
     * @param {number} startTime
     * @param {number} timeConstant
     */

  }, {
    key: "setTargetAtTime",
    value: function setTargetAtTime(target, startTime, timeConstant) {
      target = toNumber(target);
      startTime = Math.max(0, toNumber(startTime));
      timeConstant = Math.max(0, toNumber(timeConstant));

      var eventItem = {
        type: SET_TARGET_AT_TIME,
        time: startTime,
        args: [target, startTime, timeConstant],
        startFrame: Math.round(startTime * this.sampleRate),
        endFrame: Infinity,
        startValue: 0,
        endValue: target
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case SET_VALUE_AT_TIME:
            eventItem.startValue = prevEventItem.endValue;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case SET_TARGET_AT_TIME:
            eventItem.startValue = 0;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          case SET_VALUE_CURVE_AT_TIME:
            eventItem.startValue = prevEventItem.endValue;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.startFrame;
            nextEventItem.startValue = eventItem.startValue;
            break;
        }
        eventItem.endFrame = nextEventItem.startFrame;
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {Float32Array[]} values
     * @param {number}         startTime
     * @param {number}         duration
     */

  }, {
    key: "setValueCurveAtTime",
    value: function setValueCurveAtTime(values, startTime, duration) {
      startTime = Math.max(0, toNumber(startTime));
      duration = Math.max(0, toNumber(duration));

      if (values.length === 0 || duration === 0) {
        return;
      }

      var eventItem = {
        type: SET_VALUE_CURVE_AT_TIME,
        time: startTime,
        args: [values, startTime, duration],
        startFrame: Math.round(startTime * this.sampleRate),
        endFrame: Math.round((startTime + duration) * this.sampleRate),
        startValue: values[0],
        endValue: values[values.length - 1]
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case SET_VALUE_AT_TIME:
          case SET_TARGET_AT_TIME:
            prevEventItem.endFrame = eventItem.startFrame;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.startFrame;
            nextEventItem.startValue = eventItem.endValue;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} startTime
     */

  }, {
    key: "cancelScheduledValues",
    value: function cancelScheduledValues(startTime) {
      startTime = Math.max(0, toNumber(startTime));

      this._timeline = this._timeline.filter(function (eventItem) {
        return eventItem.time < startTime;
      });

      var index = this._timeline.length - 1;
      var lastEventItem = this._timeline[index];

      if (lastEventItem) {
        switch (lastEventItem.type) {
          case SET_VALUE_AT_TIME:
          case SET_TARGET_AT_TIME:
            lastEventItem.endFrame = Infinity;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @return {string}
     */

  }, {
    key: "getRate",
    value: function getRate() {
      return this._rate;
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "hasSampleAccurateValues",
    value: function hasSampleAccurateValues() {
      return this._hasSampleAccurateValues;
    }

    /**
     * @return {Float32Array}
     */

  }, {
    key: "getSampleAccurateValues",
    value: function getSampleAccurateValues() {
      return this.outputBus.getChannelData()[0];
    }

    /**
     *
     */

  }, {
    key: "enableOutputsIfNecessary",
    value: function enableOutputsIfNecessary() {}

    /**
     *
     */

  }, {
    key: "disableOutputsIfNecessary",
    value: function disableOutputsIfNecessary() {}

    /**
     * @return {object[]}
     */

  }, {
    key: "getTimeline",
    value: function getTimeline() {
      return this._timeline;
    }

    /**
     * @return {object[]}
     */

  }, {
    key: "getEvents",
    value: function getEvents() {
      return this._timeline.map(function (event) {
        return { type: event.type, time: event.time, args: event.args };
      });
    }

    /**
     * @param {object}
     * @return {number}
     */

  }, {
    key: "insertEvent",
    value: function insertEvent(eventItem) {
      var time = eventItem.time;
      var timeline = this._timeline;

      if (timeline.length === 0 || timeline[timeline.length - 1].time < time) {
        timeline.push(eventItem);
        return timeline.length - 1;
      }

      var pos = 0;
      var replace = 0;

      while (pos < timeline.length) {
        if (timeline[pos].time === time && timeline[pos].type === eventItem.type) {
          replace = 1;
          break;
        }
        if (time < timeline[pos].time) {
          break;
        }
        pos += 1;
      }

      timeline.splice(pos, replace, eventItem);

      return pos;
    }
  }]);

  return AudioParam;
}();

Object.assign(AudioParam.prototype, AudioParamDSP);

module.exports = AudioParam;